}
else { # no decomposition
model<-auto.arima(train_ts,xreg=xregs,seasonal=seasonal,lambda=bc_lambda,biasadj = FALSE,trace = TRUE) # find best model on the current train set
}
cat('training: ',i%/%(batch*hor),'\n') # print number of retrainings and the type of model
}
else{ # it is not the time to retrain
if (dec){
if (!is.null(xregs))
{
model<-stlm(train_ts,model=model$model,modelfunction=function(x, ...) {Arima(x, xreg=xregs, ...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
else {
model<-stlm(train_ts,model=model,s.window=7,robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
}
else
{
model<-Arima(train_ts,model=model,xreg=xregs,lambda=bc_lambda,biasadj=FALSE) # do not train, use current model with new observations
}
}
test_pred[(i%/%hor)+1,]<-forecast(model,h=hor,xreg=xregs_pred,lambda=bc_lambda,biasadj=FALSE)$mean # predict new values
}
return(test_pred)
}
arima<-function(train,test,hor=1,batch=7,freq=48,freqs=NULL,ord=NULL,wxregs_train=NULL,wxregs_test=NULL,bc=FALSE,dec=FALSE){
test_pred<-data.frame(matrix(data=NA,nrow=nrow(test),ncol=ncol(test),dimnames=list(rownames(test),colnames(test))),check.names = FALSE) # initialize matrix for predictions
train<-c(t(train)) # flatten train set
test<-c(t(test)) # flatten test set
if (is.null(ord)){ # not considering multiple seasonalities
fxregs_train<-NULL
fxregs_test<-NULL
seasonal<-TRUE
}
else { # considering multiple seasonalities
fxregs<-fourier(msts(c(train,test),seasonal.periods=freqs),K=ord)
fxregs_train<-fxregs[1:length(train),]
fxregs_test<-fxregs[1:length(test),]
seasonal<-FALSE
}
if (is.null(wxregs_train)|is.null(wxregs_test)) # not considering weather regressors
{
wxregs_train<-NULL
wxregs_test<-NULL
}
else{ # considering weather regressors
wxregs_train<-do.call(cbind,lapply(wxregs_train,function(x) c(t(x)))) # flatten and combine weather regressors for train set
wxregs_test<-do.call(cbind,lapply(wxregs_test,function(x) c(t(x)))) # flatten and combine weather regressors for test set
}
train<-c(t(train))[1:(48*28*2)]
wxregs_train<-wxregs_train[1:(48*28*2),]
xregs_train<-cbind(fxregs_train,wxregs_train) # combine fourier & weather into one matrix for train set
xregs_test<-cbind(fxregs_test,wxregs_test) # combine fourier & weather into one matrix for test set
xregs=NULL # default covariates
xregs_pred=NULL # default covariates for predictions
model<-NULL
for (i in seq(0,length(test)-hor,hor)){ # for each window of observations in test set
train_ts<-ts(c(train,test[seq_len(i)]),frequency=freq) # add new observations from test set to the current train set
if (!is.null(xregs_train)&!is.null(xregs_test)){ # if considering external regressors
xregs<-rbind(xregs_train,xregs_test[seq_len(i),]) # add covariates corresponding to new observations
xregs_pred<-matrix(xregs_test[i+seq_len(hor),],ncol=ncol(xregs_test)) # add covariates for predictions
}
if (i%%(batch*hor)==0){ # if its time to retrain
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
if (dec){ # if decomposition is to be applied
model<-stlm(train_ts,method='arima',xreg=xregs,s.window=7,robust=TRUE,lambda=bc_lambda,biasadj = FALSE,trace=TRUE) # find best model on the current train set
}
else { # no decomposition
model<-auto.arima(train_ts,xreg=xregs,seasonal=FALSE,lambda=bc_lambda,biasadj = FALSE,trace = TRUE) # find best model on the current train set
}
cat('training: ',i%/%(batch*hor),'\n') # print number of retrainings and the type of model
}
else{ # it is not the time to retrain
if (dec){
if (!is.null(xregs))
{
model<-stlm(train_ts,model=model$model,modelfunction=function(x, ...) {Arima(x, xreg=xregs, ...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
else {
model<-stlm(train_ts,model=model,s.window=7,robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
}
else
{
model<-Arima(train_ts,model=model,xreg=xregs,lambda=bc_lambda,biasadj=FALSE) # do not train, use current model with new observations
}
}
test_pred[(i%/%hor)+1,]<-forecast(model,h=hor,xreg=xregs_pred,lambda=bc_lambda,biasadj=FALSE)$mean # predict new values
}
return(test_pred)
}
test_pred_hw<-arima_h(train,test,batch=28,freq=48,wxregs_train=wxregs_train,wxregs_test=wxregs_test,dec=dec,bc = bc) # horizontal prediction
arima<-function(train,test,hor=1,batch=7,freq=48,freqs=NULL,ord=NULL,wxregs_train=NULL,wxregs_test=NULL,bc=FALSE,dec=FALSE){
test_pred<-data.frame(matrix(data=NA,nrow=nrow(test),ncol=ncol(test),dimnames=list(rownames(test),colnames(test))),check.names = FALSE) # initialize matrix for predictions
train<-c(t(train)) # flatten train set
test<-c(t(test)) # flatten test set
if (is.null(ord)){ # not considering multiple seasonalities
fxregs_train<-NULL
fxregs_test<-NULL
seasonal<-TRUE
}
else { # considering multiple seasonalities
fxregs<-fourier(msts(c(train,test),seasonal.periods=freqs),K=ord)
fxregs_train<-fxregs[1:length(train),]
fxregs_test<-fxregs[1:length(test),]
seasonal<-FALSE
}
if (is.null(wxregs_train)|is.null(wxregs_test)) # not considering weather regressors
{
wxregs_train<-NULL
wxregs_test<-NULL
}
else{ # considering weather regressors
wxregs_train<-do.call(cbind,lapply(wxregs_train,function(x) c(t(x)))) # flatten and combine weather regressors for train set
wxregs_test<-do.call(cbind,lapply(wxregs_test,function(x) c(t(x)))) # flatten and combine weather regressors for test set
}
#train<-c(t(train))[1:(48*28*2)]
#wxregs_train<-wxregs_train[1:(48*28*2),]
xregs_train<-cbind(fxregs_train,wxregs_train) # combine fourier & weather into one matrix for train set
xregs_test<-cbind(fxregs_test,wxregs_test) # combine fourier & weather into one matrix for test set
xregs=NULL # default covariates
xregs_pred=NULL # default covariates for predictions
model<-NULL
for (i in seq(0,length(test)-hor,hor)){ # for each window of observations in test set
train_ts<-ts(c(train,test[seq_len(i)]),frequency=freq) # add new observations from test set to the current train set
if (!is.null(xregs_train)&!is.null(xregs_test)){ # if considering external regressors
xregs<-rbind(xregs_train,xregs_test[seq_len(i),]) # add covariates corresponding to new observations
xregs_pred<-matrix(xregs_test[i+seq_len(hor),],ncol=ncol(xregs_test)) # add covariates for predictions
}
if (i%%(batch*hor)==0){ # if its time to retrain
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
if (dec){ # if decomposition is to be applied
model<-stlm(train_ts,method='arima',xreg=xregs,s.window=7,robust=TRUE,lambda=bc_lambda,biasadj = FALSE,trace=TRUE) # find best model on the current train set
}
else { # no decomposition
model<-auto.arima(train_ts,xreg=xregs,seasonal=FALSE,lambda=bc_lambda,biasadj = FALSE,trace = TRUE) # find best model on the current train set
}
cat('training: ',i%/%(batch*hor),'\n') # print number of retrainings and the type of model
}
else{ # it is not the time to retrain
if (dec){
if (!is.null(xregs))
{
model<-stlm(train_ts,model=model$model,modelfunction=function(x, ...) {Arima(x, xreg=xregs, ...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
else {
model<-stlm(train_ts,model=model,s.window=7,robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
}
else
{
model<-Arima(train_ts,model=model,xreg=xregs,lambda=bc_lambda,biasadj=FALSE) # do not train, use current model with new observations
}
}
test_pred[(i%/%hor)+1,]<-forecast(model,h=hor,xreg=xregs_pred,lambda=bc_lambda,biasadj=FALSE)$mean # predict new values
}
return(test_pred)
}
test_pred_hw<-arima_h(train,test,batch=28,freq=48,wxregs_train=wxregs_train,wxregs_test=wxregs_test,dec=dec,bc = bc) # horizontal prediction
save(data=test_pred_hw,path=paste(exp_dir,'arimax/',name,'wregs,arimax.csv',sep='')) # write results
for (i in 0:6){ # for each day
day<-paste('D',i,sep='') # index name
test_pred_vwi<-arima_v(train_day[[day]],test_day[[day]],batch=4,freq=52,wxregs_train=wxregs_train_day[[day]],wxregs_test=wxregs_test_day[[day]],dec=dec,bc = bc) # horizontal predictions for this day
save(data=test_pred_vwi,path=paste(exp_dir,'arimax/','ha,',name,'wregs,arimax_',i,'.csv',sep='')) # write results
}
for (i in 0:6){ # for each day
day<-paste('D',i,sep='') # index name
test_pred_hwi<-arima_h(train_day[[day]],test_day[[day]],batch=4,freq=48,wxregs_train=wxregs_train_day[[day]],wxregs_test=wxregs_test_day[[day]],dec=dec,bc = bc) # horizontal predictions for this day
save(data=test_pred_hwi,path=paste(exp_dir,'arimax/',name,'wregs,arimax_',i,'.csv',sep='')) # write results
}
bc=TRUE
name='bc,'
test_pred_hw<-arima_h(train,test,batch=28,freq=48,wxregs_train=wxregs_train,wxregs_test=wxregs_test,dec=dec,bc = bc) # horizontal prediction
save(data=test_pred_hw,path=paste(exp_dir,'arimax/',name,'wregs,arimax.csv',sep='')) # write results
for (i in 0:6){ # for each day
day<-paste('D',i,sep='') # index name
test_pred_hwi<-arima_h(train_day[[day]],test_day[[day]],batch=4,freq=48,wxregs_train=wxregs_train_day[[day]],wxregs_test=wxregs_test_day[[day]],dec=dec,bc = bc) # horizontal predictions for this day
save(data=test_pred_hwi,path=paste(exp_dir,'arimax/',name,'wregs,arimax_',i,'.csv',sep='')) # write results
}
dec=TRUE
bc
name
name='dec,bc,'
test_pred_vfw<-arima_v(train,test,batch=28,freq=365.25,freqs=c(7),ord=3,wxregs_train=wxregs_train,wxregs_test=wxregs_test,dec=dec,bc = bc) # vertical prediction
arima<-function(train,test,hor=1,batch=7,freq=48,freqs=NULL,ord=NULL,wxregs_train=NULL,wxregs_test=NULL,bc=FALSE,dec=FALSE){
test_pred<-data.frame(matrix(data=NA,nrow=nrow(test),ncol=ncol(test),dimnames=list(rownames(test),colnames(test))),check.names = FALSE) # initialize matrix for predictions
train<-c(t(train)) # flatten train set
test<-c(t(test)) # flatten test set
if (is.null(ord)){ # not considering multiple seasonalities
fxregs_train<-NULL
fxregs_test<-NULL
seasonal<-TRUE
}
else { # considering multiple seasonalities
fxregs<-fourier(msts(c(train,test),seasonal.periods=freqs),K=ord)
fxregs_train<-fxregs[1:length(train),]
fxregs_test<-fxregs[1:length(test),]
seasonal<-FALSE
}
if (is.null(wxregs_train)|is.null(wxregs_test)) # not considering weather regressors
{
wxregs_train<-NULL
wxregs_test<-NULL
}
else{ # considering weather regressors
wxregs_train<-do.call(cbind,lapply(wxregs_train,function(x) c(t(x)))) # flatten and combine weather regressors for train set
wxregs_test<-do.call(cbind,lapply(wxregs_test,function(x) c(t(x)))) # flatten and combine weather regressors for test set
}
#train<-c(t(train))[1:(48*28*2)]
#wxregs_train<-wxregs_train[1:(48*28*2),]
xregs_train<-cbind(fxregs_train,wxregs_train) # combine fourier & weather into one matrix for train set
xregs_test<-cbind(fxregs_test,wxregs_test) # combine fourier & weather into one matrix for test set
xregs=NULL # default covariates
xregs_pred=NULL # default covariates for predictions
model<-NULL
for (i in seq(0,length(test)-hor,hor)){ # for each window of observations in test set
train_ts<-ts(c(train,test[seq_len(i)]),frequency=freq) # add new observations from test set to the current train set
if (!is.null(xregs_train)&!is.null(xregs_test)){ # if considering external regressors
xregs<-rbind(xregs_train,xregs_test[seq_len(i),]) # add covariates corresponding to new observations
xregs_pred<-matrix(xregs_test[i+seq_len(hor),],ncol=ncol(xregs_test)) # add covariates for predictions
}
if (i%%(batch*hor)==0){ # if its time to retrain
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
if (dec){ # if decomposition is to be applied
model<-stlm(train_ts,method='arima',xreg=xregs,s.window=7,robust=TRUE,lambda=bc_lambda,biasadj = FALSE,trace=TRUE) # find best model on the current train set
}
else { # no decomposition
model<-auto.arima(train_ts,xreg=xregs,seasonal=seasonal,lambda=bc_lambda,biasadj = FALSE,trace = TRUE) # find best model on the current train set
}
cat('training: ',i%/%(batch*hor),'\n') # print number of retrainings and the type of model
}
else{ # it is not the time to retrain
if (dec){
if (!is.null(xregs))
{
model<-stlm(train_ts,model=model$model,modelfunction=function(x, ...) {Arima(x, xreg=xregs, ...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
else {
model<-stlm(train_ts,model=model,s.window=7,robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
}
else
{
model<-Arima(train_ts,model=model,xreg=xregs,lambda=bc_lambda,biasadj=FALSE) # do not train, use current model with new observations
}
}
test_pred[(i%/%hor)+1,]<-forecast(model,h=hor,xreg=xregs_pred,lambda=bc_lambda,biasadj=FALSE)$mean # predict new values
}
return(test_pred)
}
test_pred_vfw<-arima_v(train,test,batch=28,freq=365.25,freqs=c(7),ord=3,wxregs_train=wxregs_train,wxregs_test=wxregs_test,dec=dec,bc = bc) # vertical prediction
save(data=test_pred_vfw,path=paste(exp_dir,'arimax/','ha,',name,'fregs,wregs,arimax.csv',sep='')) # write results
data_dir<-'C:/Users/SABA/Google Drive/mtsg/data/experiments/data/' # directory containing data
exp_dir<-'C:/Users/SABA/Google Drive/mtsg/data/experiments/' # directory for the results of experiments
train<-load(paste(data_dir,'train.csv', sep='')) # load train set
test<-load(paste(data_dir,'test.csv', sep='')) # load test set
wxregs_train<-lapply(list('tempm_train.csv','hum_train.csv','pressurem.csv'),function(x) load(paste(data_dir,x,sep=''))) # load weather covariates for train set
wxregs_test<-lapply(list('tempm_test.csv','hum_test.csv','pressurem.csv'),function(x) load(paste(data_dir,x,sep=''))) # load weather covariates for test set
train_day<-sapply(paste('D',seq(0,6),sep=''),function(x) NULL) # initialize empty list for train days
test_day<-sapply(paste('D',seq(0,6),sep=''),function(x) NULL) # initialize empty list for test days
wxregs_train_day<-sapply(paste('D',seq(0,6),sep=''),function(x) NULL) # initialize empty list for train weather day
wxregs_test_day<-sapply(paste('D',seq(0,6),sep=''),function(x) NULL) # initialize empty list for test weather day
for (i in 0:6){
day<-paste('D',i,sep='') # index name
train_day[[day]]<-load(paste(data_dir,'train_',i,'.csv', sep='')) # load train day
test_day[[day]]<-load(paste(data_dir,'test_',i,'.csv', sep='')) # load test day
wxregs_train_day[[day]]<-lapply(list('tempm_train_','hum_train_','pressurem_train_'),function(x) load(paste(data_dir,x,i,'.csv',sep=''))) # load weather for train day
wxregs_test_day[[day]]<-lapply(list('tempm_test_','hum_test_','pressurem_test_'),function(x) load(paste(data_dir,x,i,'.csv',sep=''))) # load weather for test day
}
params<-data.frame(row.names=c('np,','bc,','dec,','dec,bc,'),'bc'=c(FALSE,TRUE,FALSE,TRUE),'dec'=c(FALSE,FALSE,TRUE,TRUE))
wxregs_train<-lapply(list('tempm_train.csv','hum_train.csv','pressurem_train.csv'),function(x) load(paste(data_dir,x,sep=''))) # load weather covariates for train set
wxregs_test<-lapply(list('tempm_test.csv','hum_test.csv','pressurem_test.csv'),function(x) load(paste(data_dir,x,sep=''))) # load weather covariates for test set
train_day<-sapply(paste('D',seq(0,6),sep=''),function(x) NULL) # initialize empty list for train days
test_day<-sapply(paste('D',seq(0,6),sep=''),function(x) NULL) # initialize empty list for test days
wxregs_train_day<-sapply(paste('D',seq(0,6),sep=''),function(x) NULL) # initialize empty list for train weather day
wxregs_test_day<-sapply(paste('D',seq(0,6),sep=''),function(x) NULL) # initialize empty list for test weather day
for (i in 0:6){
day<-paste('D',i,sep='') # index name
train_day[[day]]<-load(paste(data_dir,'train_',i,'.csv', sep='')) # load train day
test_day[[day]]<-load(paste(data_dir,'test_',i,'.csv', sep='')) # load test day
wxregs_train_day[[day]]<-lapply(list('tempm_train_','hum_train_','pressurem_train_'),function(x) load(paste(data_dir,x,i,'.csv',sep=''))) # load weather for train day
wxregs_test_day[[day]]<-lapply(list('tempm_test_','hum_test_','pressurem_test_'),function(x) load(paste(data_dir,x,i,'.csv',sep=''))) # load weather for test day
}
params<-data.frame(row.names=c('np,','bc,','dec,','dec,bc,'),'bc'=c(FALSE,TRUE,FALSE,TRUE),'dec'=c(FALSE,FALSE,TRUE,TRUE))
name<-''
bc<-FALSE
dec<-FALSE
arima<-function(train,test,hor=1,batch=7,freq=48,freqs=NULL,ord=NULL,wxregs_train=NULL,wxregs_test=NULL,bc=FALSE,dec=FALSE){
test_pred<-data.frame(matrix(data=NA,nrow=nrow(test),ncol=ncol(test),dimnames=list(rownames(test),colnames(test))),check.names = FALSE) # initialize matrix for predictions
train<-c(t(train)) # flatten train set
test<-c(t(test)) # flatten test set
if (is.null(ord)){ # not considering multiple seasonalities
fxregs_train<-NULL
fxregs_test<-NULL
seasonal<-TRUE
}
else { # considering multiple seasonalities
fxregs<-fourier(msts(c(train,test),seasonal.periods=freqs),K=ord)
fxregs_train<-fxregs[1:length(train),]
fxregs_test<-fxregs[1:length(test),]
seasonal<-FALSE
}
if (is.null(wxregs_train)|is.null(wxregs_test)) # not considering weather regressors
{
wxregs_train<-NULL
wxregs_test<-NULL
}
else{ # considering weather regressors
wxregs_train<-do.call(cbind,lapply(wxregs_train,function(x) c(t(x)))) # flatten and combine weather regressors for train set
wxregs_test<-do.call(cbind,lapply(wxregs_test,function(x) c(t(x)))) # flatten and combine weather regressors for test set
}
#train<-c(t(train))[1:(48*28*2)]
#wxregs_train<-wxregs_train[1:(48*28*2),]
xregs_train<-cbind(fxregs_train,wxregs_train) # combine fourier & weather into one matrix for train set
xregs_test<-cbind(fxregs_test,wxregs_test) # combine fourier & weather into one matrix for test set
xregs=NULL # default covariates
xregs_pred=NULL # default covariates for predictions
model<-NULL
for (i in seq(0,length(test)-hor,hor)){ # for each window of observations in test set
train_ts<-ts(c(train,test[seq_len(i)]),frequency=freq) # add new observations from test set to the current train set
if (!is.null(xregs_train)&!is.null(xregs_test)){ # if considering external regressors
xregs<-rbind(xregs_train,xregs_test[seq_len(i),]) # add covariates corresponding to new observations
xregs_pred<-matrix(xregs_test[i+seq_len(hor),],ncol=ncol(xregs_test)) # add covariates for predictions
}
if (i%%(batch*hor)==0){ # if its time to retrain
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
if (dec){ # if decomposition is to be applied
model<-stlm(train_ts,method='arima',xreg=xregs,s.window=7,robust=TRUE,lambda=bc_lambda,biasadj = FALSE,trace=TRUE) # find best model on the current train set
}
else { # no decomposition
model<-auto.arima(train_ts,xreg=xregs,seasonal=FALSE,lambda=bc_lambda,biasadj = FALSE,trace = TRUE) # find best model on the current train set
}
cat('training: ',i%/%(batch*hor),'\n') # print number of retrainings and the type of model
}
else{ # it is not the time to retrain
if (dec){
if (!is.null(xregs))
{
model<-stlm(train_ts,model=model$model,modelfunction=function(x, ...) {Arima(x, xreg=xregs, ...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
else {
model<-stlm(train_ts,model=model,s.window=7,robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
}
else
{
model<-Arima(train_ts,model=model,xreg=xregs,lambda=bc_lambda,biasadj=FALSE) # do not train, use current model with new observations
}
}
test_pred[(i%/%hor)+1,]<-forecast(model,h=hor,xreg=xregs_pred,lambda=bc_lambda,biasadj=FALSE)$mean # predict new values
}
return(test_pred)
}
test_pred_hw<-arima_h(train,test,batch=28,freq=48,wxregs_train=wxregs_train,wxregs_test=wxregs_test,dec=dec,bc = bc) # horizontal prediction
save(data=test_pred_hw,path=paste(exp_dir,'arimax/',name,'wregs,arimax.csv',sep='')) # write results
# ha
test_pred_vw<-arima_v(train,test,batch=28,freq=7,wxregs_train=wxregs_train,wxregs_test=wxregs_test,dec=dec,bc = bc) # vertical prediction
save(data=test_pred_vw,path=paste(exp_dir,'arimax/','ha,',name,'wregs,arimax.csv',sep='')) # write results
# wa
for (i in 0:6){ # for each day
day<-paste('D',i,sep='') # index name
test_pred_hwi<-arima_h(train_day[[day]],test_day[[day]],batch=4,freq=48,wxregs_train=wxregs_train_day[[day]],wxregs_test=wxregs_test_day[[day]],dec=dec,bc = bc) # horizontal predictions for this day
save(data=test_pred_hwi,path=paste(exp_dir,'arimax/',name,'wregs,arimax_',i,'.csv',sep='')) # write results
}
# wa & ha
for (i in 0:6){ # for each day
day<-paste('D',i,sep='') # index name
test_pred_vwi<-arima_v(train_day[[day]],test_day[[day]],batch=4,freq=52,wxregs_train=wxregs_train_day[[day]],wxregs_test=wxregs_test_day[[day]],dec=dec,bc = bc) # horizontal predictions for this day
save(data=test_pred_vwi,path=paste(exp_dir,'arimax/','ha,',name,'wregs,arimax_',i,'.csv',sep='')) # write results
}
dec=TRUE
bc
name='dec,cv7,'
test_pred_v<-arima_v(train,test,batch=28,freq=7,dec=dec,bc = bc) # predict values
test_pred_v<-arima_v(train,test,batch=7,freq=7,dec=dec,bc = bc) # predict values
save(data=test_pred_v,path=paste(exp_dir,'arima/','ha,',name,'arima','.csv',sep='')) # write results
test_pred_vf<-arima_v(train,test,batch=7,freq=365.25,freqs=c(7),ord=3,dec=dec,bc = bc) # horizontal prediction
name
test_pred_vf<-arima_v(train,test,batch=7,freq=365.25,freqs=c(7),ord=3,dec=dec,bc = bc) # horizontal prediction
save(data=test_pred_vf,path=paste(exp_dir,'arimax/','ha,',name,'fregs,arimax.csv',sep='')) # write results
?trunc
trunc(5.5)
trunc(5.9)
?rep
n-(m:1)+1
n=28
m=7
n-(m:1)+1
?stl
stl(ts(c(t(train)),frequency = 48),s.window=7,robust=TRUE)
plot(stl(ts(c(t(train)),frequency = 48),s.window=7,robust=TRUE))
plot(stl(ts(c(t(train)),frequency = 48*365.25),s.window=7,robust=TRUE))
plot(stl(ts(c(t(train)),frequency = 48),s.window=7,robust=TRUE))
plot(stl(ts(c(t(train)),frequency = 48),s.window=7,robust=TRUE)[1:48*7,])
plot(stl(ts(c(t(train)),frequency = 48),s.window=7,robust=TRUE)[1:(48*7),])
?plot.stl
stl(ts(c(t(train)),frequency = 48),s.window=7,robust=TRUE)$seasonal
stl(ts(c(t(train)),frequency = 48),s.window=7,robust=TRUE)
?stl
stl(ts(c(t(train)),frequency = 48),s.window=7,robust=TRUE)$time.series$seasonal
stl(ts(c(t(train)),frequency = 48),s.window=7,robust=TRUE)$time.series
stl(ts(c(t(train)),frequency = 48),s.window=7,robust=TRUE)$time.series['seasonal']
stl=stl(ts(c(t(train)),frequency = 48),s.window=7,robust=TRUE)$time.series
stl=stl(ts(c(t(train)),frequency = 48),s.window=7,robust=TRUE)$time.series[,2]
stl=stl(ts(c(t(train)),frequency = 48),s.window=7,robust=TRUE)$time.series
stl[,2]
plot(stl[,2])
plot(stl[,1])
plot(stl[;10,1])
plot(stl[:10,1])
plot(stl[1:10,1])
plot(stl[1:48*7,1])
?plot
plot(stl[1:48*7,1],type='l')
plot(stl[1:48*28,1],type='l')
plot(stl[1:(48*28),1],type='l')
plot(stl[1:(48*7),1],type='l')
plot(stl[1:(48*28),1],type='l')
?frequency
?find.frequency
?findfrequency
?find_frequency
findfrequency(stl[,1])
library(forecast)
findfrequency(stl[,1])
plot(stl[1:(48*7),1],type='l')
?stl
plot(stl(ts(c(t(train)),frequency = 48),s.window=7,robust=TRUE)$time.series[,1],type='l')
plot(stl(ts(c(t(train)),frequency = 48),s.window=48,robust=TRUE)$time.series[,1],type='l')
?stl
plot(stl(ts(c(t(train)),frequency = 48),s.window=49,robust=TRUE)$time.series[,1],type='l')
plot(stl(ts(c(t(train)),frequency = 48),s.window=49,robust=TRUE)$time.series[1:(48*7),1],type='l')
plot(stl(ts(c(t(train)),frequency = 48),s.window=7,robust=TRUE)$time.series[1:(48*7),1],type='l')
plot(stl(ts(c(t(train)),frequency = 48),s.window=49,robust=TRUE)$time.series[1:(48*7),1],type='l')
plot(stl(ts(c(t(train)),frequency = 48),s.window=13,robust=TRUE)$time.series[1:(48*7),1],type='l')
plot(stl(ts(c(t(train)),frequency = 48),s.window=49,robust=TRUE)$time.series[1:(48*7),1],type='l')
stl=stl(ts(c(t(train)),frequency = 48),s.window=49,robust=TRUE)
plot(stl)
stl=stl(ts(c(t(train)),frequency = 48),s.window='periodic',robust=TRUE)
plot(stl)
plot(stl[,1],type='l')
plot(stl[1:(48*7),1],type='l')
plot(stl$time.series[1:(48*7),1],type='l')
plot(stl)
stl=stl(ts(c(t(train)),frequency = 48),s.window=7,robust=TRUE)
plot(stl)
?stl
stl
?type
typeof(stl)
stl=stl(ts(c(t(train)),frequency = 48),s.window=7,robust=TRUE)$time.series
stl
typeof(stl)
names(stl)
typeof(stl)
?names
stl.names
stl$names
stl.ts[,'remainder']
stl[,'remainder']
stl['remainder']
stl[,'remainder']
stl
data_dir<-'C:/Users/SABA/Google Drive/mtsg/data/' # directory containing data
data<-load(paste(data_dir,'data_imp.csv', sep='')) # load train set
source('dataprep.R')
data<-load(paste(data_dir,'data_imp.csv', sep='')) # load train set
data<-load(paste(data_dir,'data_imp.csv', sep=''),idx='datetime') # load train set
lambda<-BoxCox.lambda(train,method='loglik')
library(forecast)
lambda<-BoxCox.lambda(train,method='loglik')
lambda<-BoxCox.lambda(data,method='loglik')
lambda
data
c(t(data))
ts(data,frequency=48)
lambda<-BoxCox.lambda(ts(data,frequency=48),method='loglik')
lambda<-BoxCox.lambda(ts(data,frequency=48),method='loglik')
lambda
?BoxCox
BoxCox(ts(data,frequency=48),lambda)
data_bc<-BoxCox(ts(data,frequency=48),lambda)
rownames(data_bc)
data.frame(data_bc,dimnames=list(rownames(data),colnames(data)),check.names=FALSE)
?data.frame
data.frame(data_bc,row.names=rownames(data),check.names=FALSE)
data_bc<-data.frame(data_bc,row.names=rownames(data),check.names=FALSE)
save(data=data_bc,path=paste(data_dir,'data_bc.csv',sep=''))
gc()
data<-load(paste(data_dir,'data_all.csv', sep=''),idx='datetime') # load train set
data<-load(paste(data_dir,'data_all.csv', sep=''),idx='datetime') # load train set
data<-load(paste(data_dir,'data_all.csv', sep=''),idx='date') # load train set
data
data_ts<-ts(c(t(data)),frequency=48)
data_ts
lambda<-BoxCox.lambda(data_ts,method='loglik')
lambda
69120/1440
data_bc<-BoxCox(data_ts,lambda)
data<-load(paste(data_dir,'data_all.csv', sep=''),idx='date') # load train set
data
data<-load(paste(data_dir,'data_all.csv', sep=''),idx='date') # load train set
data
data_ts<-ts(data,frequency=48)
data_ts
lambda<-BoxCox.lambda(data_ts,method='loglik')
lambda
data_bc<-BoxCox(data_ts,lambda)
data_bc
data_bc<-data.frame(data_bc,row.names=rownames(data),check.names=FALSE)
data_bc
save(data=data_bc,path=paste(data_dir,'data_bc.csv',sep=''))
