{
wxregs_train<-NULL
wxregs_test<-NULL
}
else{ # considering weather regressors
wxregs_train<-do.call(cbind,lapply(wxregs_train,function(x) c(t(x)))) # flatten and combine weather regressors for train set
wxregs_test<-do.call(cbind,lapply(wxregs_test,function(x) c(t(x)))) # flatten and combine weather regressors for test set
}
xregs_train<-cbind(fxregs_train,wxregs_train) # combine fourier & weather into one matrix for train set
xregs_test<-cbind(fxregs_test,wxregs_test) # combine fourier & weather into one matrix for test set
xregs=NULL # default covariates
xregs_pred=NULL # default covariates for predictions
for (i in seq(0,length(test)-hor,hor)){ # for each window of observations in test set
train_ts<-ts(c(train,test[seq_len(i)]),frequency=freq) # add new observations from test set to the current train set
if (!is.null(xregs_train)&!is.null(xregs_test)){ # if considering external regressors
xregs<-rbind(xregs_train,xregs_test[seq_len(i),]) # add covariates corresponding to new observations
xregs_pred<-matrix(xregs_test[i+seq_len(hor),],ncol=ncol(xregs_test)) # add covariates for predictions
}
if (i%%(batch*hor)==0){ # if its time to retrain
model<-NULL
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
if (dec){ # if decomposition is to be applied
model<-stlm(train_ts,method='arima',xreg=xregs,s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE,trace=TRUE) # find best model on the current train set
}
else { # no decomposition
model<-auto.arima(train_ts,xreg=xregs,lambda=bc_lambda,biasadj = FALSE,trace = TRUE) # find best model on the current train set
}
cat(i%/%(batch*hor),'\n') # print number of retrainings and the type of model
}
else{ # it is not the time to retrain
if (dec){
model<-stlm(train_ts,model=model$model,modelfunction=function(x, ...) {Arima(x, xreg=xregs, ...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
else
{
model<-Arima(train_ts,model=model,xreg=xregs,lambda=bc_lambda,biasadj=FALSE) # do not train, use current model with new observations
}
}
test_pred[(i%/%hor)+1,]<-forecast(model,h=hor,xreg=xregs_pred,lambda=bc_lambda,biasadj=FALSE)$mean # predict new values
#test_pred[(i%/%hor)+1,]<-forecast(model,h=hor,xreg=xregs_pred,lambda=bc_lambda,biasadj=FALSE)$mean # predict new values
}
return(test_pred)
}
test_pred_h<-arima_h(train,test,batch=28,freq=48,dec=dec,bc = bc) # predict values
arima<-function(train,test,hor=1,batch=7,freq=48,freqs=NULL,ord=NULL,wxregs_train=NULL,wxregs_test=NULL,bc=FALSE,dec=FALSE){
test_pred<-data.frame(matrix(data=NA,nrow=nrow(test),ncol=ncol(test),dimnames=list(rownames(test),colnames(test))),check.names = FALSE) # initialize matrix for predictions
train<-c(t(train)) # flatten train set
test<-c(t(test)) # flatten test set
if (is.null(ord)){ # not considering multiple seasonalities
fxregs_train<-NULL
fxregs_test<-NULL
}
else { # considering multiple seasonalities
fxregs_train<-fourier(msts(train,seasonal.periods=freqs),K=ord)
fxregs_test<-fourier(msts(test,seasonal.periods=freqs),K=ord)
}
if (is.null(wxregs_train)|is.null(wxregs_test)) # not considering weather regressors
{
wxregs_train<-NULL
wxregs_test<-NULL
}
else{ # considering weather regressors
wxregs_train<-do.call(cbind,lapply(wxregs_train,function(x) c(t(x)))) # flatten and combine weather regressors for train set
wxregs_test<-do.call(cbind,lapply(wxregs_test,function(x) c(t(x)))) # flatten and combine weather regressors for test set
}
xregs_train<-cbind(fxregs_train,wxregs_train) # combine fourier & weather into one matrix for train set
xregs_test<-cbind(fxregs_test,wxregs_test) # combine fourier & weather into one matrix for test set
xregs=NULL # default covariates
xregs_pred=NULL # default covariates for predictions
for (i in seq(0,length(test)-hor,hor)){ # for each window of observations in test set
train_ts<-ts(c(train,test[seq_len(i)]),frequency=freq) # add new observations from test set to the current train set
if (!is.null(xregs_train)&!is.null(xregs_test)){ # if considering external regressors
xregs<-rbind(xregs_train,xregs_test[seq_len(i),]) # add covariates corresponding to new observations
xregs_pred<-matrix(xregs_test[i+seq_len(hor),],ncol=ncol(xregs_test)) # add covariates for predictions
}
if (i%%(batch*hor)==0){ # if its time to retrain
model<-NULL
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
if (dec){ # if decomposition is to be applied
model<-stlm(train_ts,method='arima',xreg=xregs,s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE,trace=TRUE) # find best model on the current train set
}
else { # no decomposition
model<-auto.arima(train_ts,xreg=xregs,lambda=bc_lambda,biasadj = FALSE,trace = TRUE) # find best model on the current train set
}
cat(i%/%(batch*hor),'\n') # print number of retrainings and the type of model
}
else{ # it is not the time to retrain
if (dec){
model<-stlm(train_ts,model=model$model,modelfunction=function(x, ...) {Arima(x, xreg=xregs, ...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
else
{
model<-Arima(train_ts,model=model,xreg=xregs,lambda=bc_lambda,biasadj=FALSE) # do not train, use current model with new observations
}
}
test_pred[(i%/%hor)+1,]<-forecast(model,h=hor,lambda=bc_lambda,biasadj=FALSE)$mean # predict new values
#test_pred[(i%/%hor)+1,]<-forecast(model,h=hor,xreg=xregs_pred,lambda=bc_lambda,biasadj=FALSE)$mean # predict new values
}
return(test_pred)
}
test_pred_h<-arima_h(train,test,batch=28,freq=48,dec=dec,bc = bc) # predict values
test_pred_h<-arima_h(train,test,batch=28,freq=48,dec=dec,bc = bc) # predict values
if (NULL) {print('yres')}
arima<-function(train,test,hor=1,batch=7,freq=48,freqs=NULL,ord=NULL,wxregs_train=NULL,wxregs_test=NULL,bc=FALSE,dec=FALSE){
test_pred<-data.frame(matrix(data=NA,nrow=nrow(test),ncol=ncol(test),dimnames=list(rownames(test),colnames(test))),check.names = FALSE) # initialize matrix for predictions
train<-c(t(train)) # flatten train set
test<-c(t(test)) # flatten test set
if (is.null(ord)){ # not considering multiple seasonalities
fxregs_train<-NULL
fxregs_test<-NULL
}
else { # considering multiple seasonalities
fxregs_train<-fourier(msts(train,seasonal.periods=freqs),K=ord)
fxregs_test<-fourier(msts(test,seasonal.periods=freqs),K=ord)
}
if (is.null(wxregs_train)|is.null(wxregs_test)) # not considering weather regressors
{
wxregs_train<-NULL
wxregs_test<-NULL
}
else{ # considering weather regressors
wxregs_train<-do.call(cbind,lapply(wxregs_train,function(x) c(t(x)))) # flatten and combine weather regressors for train set
wxregs_test<-do.call(cbind,lapply(wxregs_test,function(x) c(t(x)))) # flatten and combine weather regressors for test set
}
xregs_train<-cbind(fxregs_train,wxregs_train) # combine fourier & weather into one matrix for train set
xregs_test<-cbind(fxregs_test,wxregs_test) # combine fourier & weather into one matrix for test set
xregs=NULL # default covariates
xregs_pred=NULL # default covariates for predictions
for (i in seq(0,length(test)-hor,hor)){ # for each window of observations in test set
train_ts<-ts(c(train,test[seq_len(i)]),frequency=freq) # add new observations from test set to the current train set
if (!is.null(xregs_train)&!is.null(xregs_test)){ # if considering external regressors
xregs<-rbind(xregs_train,xregs_test[seq_len(i),]) # add covariates corresponding to new observations
xregs_pred<-matrix(xregs_test[i+seq_len(hor),],ncol=ncol(xregs_test)) # add covariates for predictions
}
if (i%%(batch*hor)==0){ # if its time to retrain
model<-NULL
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
if (dec){ # if decomposition is to be applied
model<-stlm(train_ts,method='arima',xreg=xregs,s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE,trace=TRUE) # find best model on the current train set
}
else { # no decomposition
model<-auto.arima(train_ts,xreg=xregs,lambda=bc_lambda,biasadj = FALSE,trace = TRUE) # find best model on the current train set
}
cat(i%/%(batch*hor),'\n') # print number of retrainings and the type of model
}
else{ # it is not the time to retrain
if (dec){
if (!is.null(xregs))
{
model<-stlm(train_ts,model=model$model,modelfunction=function(x, ...) {Arima(x, xreg=xregs, ...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
else {
model<-stlm(train_ts,model=model$model,s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
}
else
{
model<-Arima(train_ts,model=model,xreg=xregs,lambda=bc_lambda,biasadj=FALSE) # do not train, use current model with new observations
}
}
test_pred[(i%/%hor)+1,]<-forecast(model,h=hor,xreg=xregs_pred,lambda=bc_lambda,biasadj=FALSE)$mean # predict new values
}
return(test_pred)
}
test_pred_h<-arima_h(train,test,batch=28,freq=48,dec=dec,bc = bc) # predict values
arima<-function(train,test,hor=1,batch=7,freq=48,freqs=NULL,ord=NULL,wxregs_train=NULL,wxregs_test=NULL,bc=FALSE,dec=FALSE){
test_pred<-data.frame(matrix(data=NA,nrow=nrow(test),ncol=ncol(test),dimnames=list(rownames(test),colnames(test))),check.names = FALSE) # initialize matrix for predictions
train<-c(t(train)) # flatten train set
test<-c(t(test)) # flatten test set
if (is.null(ord)){ # not considering multiple seasonalities
fxregs_train<-NULL
fxregs_test<-NULL
}
else { # considering multiple seasonalities
fxregs_train<-fourier(msts(train,seasonal.periods=freqs),K=ord)
fxregs_test<-fourier(msts(test,seasonal.periods=freqs),K=ord)
}
if (is.null(wxregs_train)|is.null(wxregs_test)) # not considering weather regressors
{
wxregs_train<-NULL
wxregs_test<-NULL
}
else{ # considering weather regressors
wxregs_train<-do.call(cbind,lapply(wxregs_train,function(x) c(t(x)))) # flatten and combine weather regressors for train set
wxregs_test<-do.call(cbind,lapply(wxregs_test,function(x) c(t(x)))) # flatten and combine weather regressors for test set
}
xregs_train<-cbind(fxregs_train,wxregs_train) # combine fourier & weather into one matrix for train set
xregs_test<-cbind(fxregs_test,wxregs_test) # combine fourier & weather into one matrix for test set
xregs=NULL # default covariates
xregs_pred=NULL # default covariates for predictions
for (i in seq(0,length(test)-hor,hor)){ # for each window of observations in test set
train_ts<-ts(c(train,test[seq_len(i)]),frequency=freq) # add new observations from test set to the current train set
if (!is.null(xregs_train)&!is.null(xregs_test)){ # if considering external regressors
xregs<-rbind(xregs_train,xregs_test[seq_len(i),]) # add covariates corresponding to new observations
xregs_pred<-matrix(xregs_test[i+seq_len(hor),],ncol=ncol(xregs_test)) # add covariates for predictions
}
if (i%%(batch*hor)==0){ # if its time to retrain
model<-NULL
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
if (dec){ # if decomposition is to be applied
model<-stlm(train_ts,method='arima',xreg=xregs,s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE,trace=TRUE) # find best model on the current train set
}
else { # no decomposition
model<-auto.arima(train_ts,xreg=xregs,lambda=bc_lambda,biasadj = FALSE,trace = TRUE) # find best model on the current train set
}
cat(i%/%(batch*hor),'\n') # print number of retrainings and the type of model
}
else{ # it is not the time to retrain
if (dec){
if (!is.null(xregs))
{
model<-stlm(train_ts,model=model$model,modelfunction=function(x, ...) {Arima(x, xreg=xregs, ...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
else {
model<-stlm(train_ts,model=model,s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
}
else
{
model<-Arima(train_ts,model=model,xreg=xregs,lambda=bc_lambda,biasadj=FALSE) # do not train, use current model with new observations
}
}
test_pred[(i%/%hor)+1,]<-forecast(model,h=hor,xreg=xregs_pred,lambda=bc_lambda,biasadj=FALSE)$mean # predict new values
}
return(test_pred)
}
test_pred_h<-arima_h(train,test,batch=28,freq=48,dec=dec,bc = bc) # predict values
save(data=test_pred_h,path=paste(exp_dir,name,'arima_h','.csv',sep='')) # write results
test_pred_v<-arima_v(train,test,batch=28,freq=7,dec=dec,bc = bc) # predict values
save(data=test_pred_v,path=paste(exp_dir,name,'arima_v','.csv',sep='')) # write results
arima_v<-function(train,test,batch=7,freq=7,ord=NULL,freqs=NULL,wxregs_train=NULL,wxregs_test=NULL,bc=FALSE,dec=FALSE){
test_pred<-data.frame(matrix(data=NA,nrow=nrow(test),ncol=ncol(test),dimnames=list(rownames(test),colnames(test))),check.names = FALSE) # initialize dataframe for predictions
for (col in names(train)){
train_col<-as.data.frame(train[[col]],row.names=rownames(train)) # convert dataframe column to dataframe
test_col<-as.data.frame(test[[col]],row.names=rownames(test)) # convert dataframe column to dataframe
colnames(train_col)<-c(col) # set column name to match
colnames(test_col)<-c(col) # set column name to match
if (is.null(wxregs_train)|is.null(wxregs_test)) # no weather regressors
{
wxregs_train_col<-NULL
wxregs_test_col<-NULL
}
else # consider weather regressors
{
wxregs_train_col<-lapply(wxregs_train,function(x) as.data.frame(`[[`(x, col))) # extract a particular column from each member of list of covariates
wxregs_test_col<-lapply(wxregs_test,function(x) as.data.frame(`[[`(x, col))) # extract a particular column from each member of list of covariates
}
test_pred[[col]]<-arima(train_col,test_col,hor=1,batch=batch,freq=freq,freqs=freqs,ord=ord,wxregs_train=wxregs_train_col,wxregs_test=wxregs_test_col)[[col]] # predictions
}
return(test_pred)
}
arima<-function(train,test,hor=1,batch=7,freq=48,freqs=NULL,ord=NULL,wxregs_train=NULL,wxregs_test=NULL,bc=FALSE,dec=FALSE){
test_pred<-data.frame(matrix(data=NA,nrow=nrow(test),ncol=ncol(test),dimnames=list(rownames(test),colnames(test))),check.names = FALSE) # initialize matrix for predictions
train<-c(t(train)) # flatten train set
test<-c(t(test)) # flatten test set
if (is.null(ord)){ # not considering multiple seasonalities
fxregs_train<-NULL
fxregs_test<-NULL
}
else { # considering multiple seasonalities
fxregs_train<-fourier(msts(train,seasonal.periods=freqs),K=ord)
fxregs_test<-fourier(msts(test,seasonal.periods=freqs),K=ord)
}
if (is.null(wxregs_train)|is.null(wxregs_test)) # not considering weather regressors
{
wxregs_train<-NULL
wxregs_test<-NULL
}
else{ # considering weather regressors
wxregs_train<-do.call(cbind,lapply(wxregs_train,function(x) c(t(x)))) # flatten and combine weather regressors for train set
wxregs_test<-do.call(cbind,lapply(wxregs_test,function(x) c(t(x)))) # flatten and combine weather regressors for test set
}
xregs_train<-cbind(fxregs_train,wxregs_train) # combine fourier & weather into one matrix for train set
xregs_test<-cbind(fxregs_test,wxregs_test) # combine fourier & weather into one matrix for test set
xregs=NULL # default covariates
xregs_pred=NULL # default covariates for predictions
for (i in seq(0,length(test)-hor,hor)){ # for each window of observations in test set
train_ts<-ts(c(train,test[seq_len(i)]),frequency=freq) # add new observations from test set to the current train set
if (!is.null(xregs_train)&!is.null(xregs_test)){ # if considering external regressors
xregs<-rbind(xregs_train,xregs_test[seq_len(i),]) # add covariates corresponding to new observations
xregs_pred<-matrix(xregs_test[i+seq_len(hor),],ncol=ncol(xregs_test)) # add covariates for predictions
}
if (i%%(batch*hor)==0){ # if its time to retrain
model<-NULL
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
if (dec){ # if decomposition is to be applied
model<-stlm(train_ts,method='arima',xreg=xregs,s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE,trace=TRUE) # find best model on the current train set
}
else { # no decomposition
model<-auto.arima(train_ts,xreg=xregs,lambda=bc_lambda,biasadj = FALSE,trace = TRUE) # find best model on the current train set
}
cat(i%/%(batch*hor),'\n') # print number of retrainings and the type of model
}
else{ # it is not the time to retrain
if (dec){
if (!is.null(xregs))
{
model<-stlm(train_ts,model=model$model,modelfunction=function(x, ...) {Arima(x, xreg=xregs, ...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
else {
model<-stlm(train_ts,model=model,s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
}
else
{
model<-Arima(train_ts,model=model,xreg=xregs,lambda=bc_lambda,biasadj=FALSE) # do not train, use current model with new observations
}
}
test_pred[(i%/%hor)+1,]<-forecast(model,h=hor,xreg=xregs_pred,lambda=bc_lambda,biasadj=FALSE)$mean # predict new values
}
return(test_pred)
}
arima_h<-function(train,test,batch=7,freq=48,freqs=NULL,ord=NULL,wxregs_train=NULL,wxregs_test=NULL,bc=FALSE,dec=FALSE){
return(arima(train,test,hor=48,batch=batch,freq=freq,freqs=freqs,ord=ord,wxregs_train=wxregs_train,wxregs_test=wxregs_test,bc = bc,dec = dec))
}
arima_v<-function(train,test,batch=7,freq=7,ord=NULL,freqs=NULL,wxregs_train=NULL,wxregs_test=NULL,bc=FALSE,dec=FALSE){
test_pred<-data.frame(matrix(data=NA,nrow=nrow(test),ncol=ncol(test),dimnames=list(rownames(test),colnames(test))),check.names = FALSE) # initialize dataframe for predictions
for (col in names(train)){
train_col<-as.data.frame(train[[col]],row.names=rownames(train)) # convert dataframe column to dataframe
test_col<-as.data.frame(test[[col]],row.names=rownames(test)) # convert dataframe column to dataframe
colnames(train_col)<-c(col) # set column name to match
colnames(test_col)<-c(col) # set column name to match
if (is.null(wxregs_train)|is.null(wxregs_test)) # no weather regressors
{
wxregs_train_col<-NULL
wxregs_test_col<-NULL
}
else # consider weather regressors
{
wxregs_train_col<-lapply(wxregs_train,function(x) as.data.frame(`[[`(x, col))) # extract a particular column from each member of list of covariates
wxregs_test_col<-lapply(wxregs_test,function(x) as.data.frame(`[[`(x, col))) # extract a particular column from each member of list of covariates
}
test_pred[[col]]<-arima(train_col,test_col,hor=1,batch=batch,freq=freq,freqs=freqs,ord=ord,wxregs_train=wxregs_train_col,wxregs_test=wxregs_test_col)[[col]] # predictions
}
return(test_pred)
}
test_pred_v<-arima_v(train,test,batch=28,freq=7,dec=dec,bc = bc) # predict values
source('arima.R')
test_pred_v<-arima_v(train,test,batch=28,freq=7,dec=dec,bc = bc) # predict values
xregs_pred
model
xregs
hor
bc_lambda
forecast(model,h=hor,xreg=xregs_pred,lambda=bc_lambda,biasadj=FALSE)$mean
model
model$model
forecast(model$model,h=hor,xreg=xregs_pred,lambda=bc_lambda,biasadj=FALSE)$mean
i
forecast(model,h=hor,lambda=bc_lambda,biasadj=FALSE)$mean
i%%(batch*hor)==0
test_pred_v<-arima_v(train,test,batch=28,freq=7,dec=dec,bc = bc) # predict values
model
dec
name
arima_v<-function(train,test,batch=7,freq=7,ord=NULL,freqs=NULL,wxregs_train=NULL,wxregs_test=NULL,bc=FALSE,dec=FALSE){
test_pred<-data.frame(matrix(data=NA,nrow=nrow(test),ncol=ncol(test),dimnames=list(rownames(test),colnames(test))),check.names = FALSE) # initialize dataframe for predictions
for (col in names(train)){
train_col<-as.data.frame(train[[col]],row.names=rownames(train)) # convert dataframe column to dataframe
test_col<-as.data.frame(test[[col]],row.names=rownames(test)) # convert dataframe column to dataframe
colnames(train_col)<-c(col) # set column name to match
colnames(test_col)<-c(col) # set column name to match
if (is.null(wxregs_train)|is.null(wxregs_test)) # no weather regressors
{
wxregs_train_col<-NULL
wxregs_test_col<-NULL
}
else # consider weather regressors
{
wxregs_train_col<-lapply(wxregs_train,function(x) as.data.frame(`[[`(x, col))) # extract a particular column from each member of list of covariates
wxregs_test_col<-lapply(wxregs_test,function(x) as.data.frame(`[[`(x, col))) # extract a particular column from each member of list of covariates
}
test_pred[[col]]<-arima(train_col,test_col,hor=1,batch=batch,freq=freq,freqs=freqs,ord=ord,wxregs_train=wxregs_train_col,wxregs_test=wxregs_test_col,dec=dec,bc=bc)[[col]] # predictions
}
return(test_pred)
}
arima_h<-function(train,test,batch=7,freq=48,freqs=NULL,ord=NULL,wxregs_train=NULL,wxregs_test=NULL,bc=FALSE,dec=FALSE){
return(arima(train,test,hor=48,batch=batch,freq=freq,freqs=freqs,ord=ord,wxregs_train=wxregs_train,wxregs_test=wxregs_test,dec = dec,bc = bc))
}
test_pred_v<-arima_v(train,test,batch=28,freq=7,dec=dec,bc = bc) # predict values
save(data=test_pred_v,path=paste(exp_dir,name,'arima_v','.csv',sep='')) # write results
test_pred_v<-arima_v(train,test,batch=28,freq=7,dec=dec,bc = bc) # predict values
save(data=test_pred_v,path=paste(exp_dir,name,'arima_v','.csv',sep='')) # write results
for (i in 0:6){ # for each day
day<-paste('D',i,sep='') # index name
test_pred_hwi<-arima_h(train_day[[day]],test_day[[day]],batch=4,freq=48,dec=dec,bc = bc) # horizontal predictions for this day
save(data=test_pred_hwi,path=paste(exp_dir,name,'arima_h_',i,'.csv',sep='')) # write results
}
for (i in 0:6){ # for each day
day<-paste('D',i,sep='') # index name
test_pred_vwi<-arima_v(train_day[[day]],test_day[[day]],batch=4,freq=52,dec=dec,bc = bc) # vertical predictions for this day
save(data=test_pred_vwi,path=paste(exp_dir,name,'arima_v_',i,'.csv',sep='')) # write results
}
test_pred_hf<-arima_h(train,test,batch=28,freq=365.25*48,freqs=c(48,7*48),ord=c(5,10),dec=dec,bc = bc) # horizontal prediction
test_pred_vf<-arima_v(train,test,batch=28,freq=365.25,freqs=c(7),ord=3,dec=dec,bc = bc) # horizontal prediction
save(data=test_pred_vf,path=paste(exp_dir,name,'fregs,arima_v.csv',sep='')) # write results
test_pred_hw<-arima_h(train,test,batch=28,freq=48,wxregs_train=wxregs_train,wxregs_test=wxregs_test,dec=dec,bc = bc) # horizontal prediction
save(data=test_pred_hw,path=paste(exp_dir,name,'wregs,arima_h.csv',sep='')) # write results
test_pred_hf<-arima_h(train,test,batch=28,freq=365.25*48,freqs=c(48,7*48),ord=c(5,10),dec=dec,bc = bc) # horizontal prediction
save(data=test_pred_hf,path=paste(exp_dir,name,'fregs,arima_h.csv',sep='')) # write results
test_pred_vw<-arima_v(train,test,batch=28,freq=7,wxregs_train=wxregs_train,wxregs_test=wxregs_test,dec=dec,bc = bc) # vertical prediction
save(data=test_pred_vw,path=paste(exp_dir,name,'wregs,arima_v.csv',sep='')) # write results
plot(train[['0000']])
?plot.ts
plot.ts(ts(train[['0000']],frequency = 1))
plot.ts(ts(train[['0000']],frequency = 1000))
plot.ts(ts(train[['0000']],frequency = 1))
plot.ts(ts(train[['0800']],frequency = 1))
?stlm
?stl
stl(train,s.window='periodic',robust=TRUE)
stl(ts(train,frequency = 356.25*48),s.window='periodic',robust=TRUE)
stl(ts(c(t(train),frequency = 356.25*48),s.window='periodic',robust=TRUE)
)
stl(ts(c(t(train)),frequency = 356.25*48),s.window='periodic',robust=TRUE)
plot.stl(stl(ts(c(t(train)),frequency = 356.25*48),s.window='periodic',robust=TRUE))
?plot.stl
plot(stl(ts(c(t(train)),frequency = 356.25*48),s.window='periodic',robust=TRUE))
plot(stl(ts(c(t(train)),frequency = 48),s.window='periodic',robust=TRUE))
plot(stl(ts(c(t(train)),frequency = 48*7),s.window='periodic',robust=TRUE))
?findfrequency
findfrequency(ts(c(t(train))))
plot(stl(ts(c(t(train)),frequency = 356.25*48),s.window='periodic',robust=TRUE))
# horizontal predictions for each day separately
for (i in 0:6){ # for each day
day<-paste('D',i,sep='') # index name
test_pred_hwi<-arima_h(train_day[[day]],test_day[[day]],batch=4,freq=48,wxregs_train=wxregs_train_day[[day]],wxregs_test=wxregs_test_day[[day]],dec=dec,bc = bc) # horizontal predictions for this day
save(data=test_pred_hwi,path=paste(exp_dir,name,'wregs,arima_h_',i,'.csv',sep='')) # write results
}
# vertical predictions for each day separately
for (i in 0:6){ # for each day
day<-paste('D',i,sep='') # index name
test_pred_vwi<-arima_v(train_day[[day]],test_day[[day]],batch=4,freq=52,wxregs_train=wxregs_train_day[[day]],wxregs_test=wxregs_test_day[[day]],dec=dec,bc = bc) # horizontal predictions for this day
save(data=test_pred_vwi,path=paste(exp_dir,name,'wregs,arima_v_',i,'.csv',sep='')) # write results
}
d=stl(ts(c(t(train)),frequency = 356.25*48),s.window='periodic',robust=TRUE)
d
d$remainder
d$time.series$remainder
d$time.series
d$time.series$remainder
d$time.series.remainder
d$time.series[,remainder]
d$time.series[,'remainder']
rem=d$time.series[,'remainder']
stl(rem,s.window = 'periodic',robust=TRUE)
plot(stl(rem,s.window = 'periodic',robust=TRUE))
rem
?ts
?frequency
plot(stl(ts(rem,frequency=48),s.window = 'periodic',robust=TRUE))
plot(stl(ts(rem,frequency=48*7),s.window = 'periodic',robust=TRUE))
test_pred_hfw<-arima_h(train,test,batch=28,freq=365.25*48,freqs=c(48,7*48),ord=c(5,10),wxregs_train=wxregs_train,wxregs_test=wxregs_test,dec=dec,bc = bc) # horizontal prediction
save(data=test_pred_hfw,path=paste(exp_dir,name,'fwregs,arima_h.csv',sep='')) # write results
# vertical predictions
test_pred_vfw<-arima_v(train,test,batch=28,freq=365.25,freqs=c(7),ord=3,wxregs_train=wxregs_train,wxregs_test=wxregs_test,dec=dec,bc = bc) # vertical prediction
save(data=test_pred_vfw,path=paste(exp_dir,name,'fwregs,arima_v.csv',sep='')) # write results
name<-'dec,'
bc<-params[name,]$bc
dec<-params[name,]$dec
bc
test_pred_h<-arima_h(train,test,batch=28,freq=48,dec=dec,bc = bc) # predict values
save(data=test_pred_h,path=paste(exp_dir,name,'arima_h','.csv',sep='')) # write results
# vertical predictions
test_pred_v<-arima_v(train,test,batch=28,freq=7,dec=dec,bc = bc) # predict values
save(data=test_pred_v,path=paste(exp_dir,name,'arima_v','.csv',sep='')) # write results
# horizontal predictions for each day separately
for (i in 0:6){ # for each day
day<-paste('D',i,sep='') # index name
test_pred_hwi<-arima_h(train_day[[day]],test_day[[day]],batch=4,freq=48,dec=dec,bc = bc) # horizontal predictions for this day
save(data=test_pred_hwi,path=paste(exp_dir,name,'arima_h_',i,'.csv',sep='')) # write results
}
# vertical predictions for each day separately
for (i in 0:6){ # for each day
day<-paste('D',i,sep='') # index name
test_pred_vwi<-arima_v(train_day[[day]],test_day[[day]],batch=4,freq=52,dec=dec,bc = bc) # vertical predictions for this day
save(data=test_pred_vwi,path=paste(exp_dir,name,'arima_v_',i,'.csv',sep='')) # write results
}
# vertical predictions
test_pred_vf<-arima_v(train,test,batch=28,freq=365.25,freqs=c(7),ord=3,dec=dec,bc = bc) # horizontal prediction
save(data=test_pred_vf,path=paste(exp_dir,name,'fregs,arima_v.csv',sep='')) # write results
# WEATHER EXTERNAL REGRESSORS
# horizontal predictions
test_pred_hw<-arima_h(train,test,batch=28,freq=48,wxregs_train=wxregs_train,wxregs_test=wxregs_test,dec=dec,bc = bc) # horizontal prediction
save(data=test_pred_hw,path=paste(exp_dir,name,'wregs,arima_h.csv',sep='')) # write results
# vertical predictions
test_pred_vw<-arima_v(train,test,batch=28,freq=7,wxregs_train=wxregs_train,wxregs_test=wxregs_test,dec=dec,bc = bc) # vertical prediction
save(data=test_pred_vw,path=paste(exp_dir,name,'wregs,arima_v.csv',sep='')) # wr
# horizontal predictions for each day separately
for (i in 0:6){ # for each day
day<-paste('D',i,sep='') # index name
test_pred_hwi<-arima_h(train_day[[day]],test_day[[day]],batch=4,freq=48,wxregs_train=wxregs_train_day[[day]],wxregs_test=wxregs_test_day[[day]],dec=dec,bc = bc) # horizontal predictions for this day
save(data=test_pred_hwi,path=paste(exp_dir,name,'wregs,arima_h_',i,'.csv',sep='')) # write results
}
# vertical predictions for each day separately
for (i in 0:6){ # for each day
day<-paste('D',i,sep='') # index name
test_pred_vwi<-arima_v(train_day[[day]],test_day[[day]],batch=4,freq=52,wxregs_train=wxregs_train_day[[day]],wxregs_test=wxregs_test_day[[day]],dec=dec,bc = bc) # horizontal predictions for this day
save(data=test_pred_vwi,path=paste(exp_dir,name,'wregs,arima_v_',i,'.csv',sep='')) # write results
}
# vertical predictions
test_pred_vfw<-arima_v(train,test,batch=28,freq=365.25,freqs=c(7),ord=3,wxregs_train=wxregs_train,wxregs_test=wxregs_test,dec=dec,bc = bc) # vertical prediction
save(data=test_pred_vfw,path=paste(exp_dir,name,'fwregs,arima_v.csv',sep='')) # write results
# horizontal predictions
test_pred_hf<-arima_h(train,test,batch=28,freq=365.25*48,freqs=c(48,7*48),ord=c(5,10),dec=dec,bc = bc) # horizontal prediction
save(data=test_pred_hf,path=paste(exp_dir,name,'fregs,arima_h.csv',sep='')) # write results
dec
bc
dec
# horizontal predictions
test_pred_hfw<-arima_h(train,test,batch=28,freq=365.25*48,freqs=c(48,7*48),ord=c(5,10),wxregs_train=wxregs_train,wxregs_test=wxregs_test,dec=dec,bc = bc) # horizontal prediction
save(data=test_pred_hfw,path=paste(exp_dir,name,'fwregs,arima_h.csv',sep='')) # write results
