for (col in names(train)){
train_col<-as.data.frame(train[[col]],row.names=rownames(train)) # convert dataframe column to dataframe
test_col<-as.data.frame(test[[col]],row.names=rownames(test)) # convert dataframe column to dataframe
colnames(train_col)<-c(col) # set column name to match
colnames(test_col)<-c(col) # set column name to match
f_K_col= if (!is.null(f_K)) f_K[[col]] else f_K
if (is.null(wxregs_train)|is.null(wxregs_test)) # no weather regressors
{
wxregs_train_col<-NULL
wxregs_test_col<-NULL
}
else # consider weather regressors
{
wxregs_train_col<-lapply(wxregs_train,function(x) as.data.frame(`[[`(x, col))) # extract a particular column from each member of list of covariates
wxregs_test_col<-lapply(wxregs_test,function(x) as.data.frame(`[[`(x, col))) # extract a particular column from each member of list of covariates
}
test_pred[[col]]<-arima(train_col,test_col,hor=1,batch=batch,freq=freq,freqs=freqs,f_K=f_K_col,wxregs_train=wxregs_train_col,wxregs_test=wxregs_test_col)[[col]] # predictions
}
return(test_pred)
}
train<-load(paste(data_dir,'train_full.csv', sep='')) # load train set
f_ords<-function(train,freq=48,freqs,ords,dec=FALSE,bc=FALSE){
train<-c(t(train)) # flatten train set
aicc_best<-Inf # best aicc statistic
param_best<-NULL # best parameters
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
for (i in 1:nrow(ords)){ # for each combination of orders
ord<-unlist(ords[i,]) # combination of orders
xreg_train<-fourier(msts(train,seasonal.periods=freqs),K=ord) # fourier terms for particular multi-seasonal time series
if (dec) # if decompose first
{
fit=stlm(ts(train,frequency = freq),method='arima',xreg=xreg_train,s.window='periodic',robust=TRUE,trace=TRUE,lambda = bc_lambda)$model  # find best arima model after decomposition
}
else{ # dont decompose
fit=auto.arima(ts(train,frequency = freq),xreg=xreg_train,seasonal=FALSE,trace=TRUE,lambda = bc_lambda) # find best arima model
}
if (fit$aicc<aicc_best){ # if there is an improvement in aicc statistic
ord_best<-ord # save these orders
aicc_best<-fit$aicc # save new best aicc value
}
}
return(ord_best)
}
data_dir<-'C:/Users/SABA/Google Drive/mtsg/data/nocb/arima/data/' # directory containing data
train<-load(paste(data_dir,'train_full.csv', sep='')) # load train set
ords<-params<-expand.grid(seq(3)) # all combinations of fourier orders to try
K_v <- sapply(names(train),function(x) NULL) # initialize empty list for orders
for (col in names(train)){
train_col<-as.data.frame(train[[col]],row.names=rownames(train)) # convert dataframe column to dataframe
colnames(train_col)<-c(col) # set column name to match
K_v[[col]]<-f_ords(train_col,freq=365.25,freqs=c(7),ords=ords) # find best fourier coefficients
}
# vertical predictions & BC
ords<-params<-expand.grid(seq(3)) # all combinations of fourier orders to try
bc_K_v <- sapply(names(train),function(x) NULL) # initialize empty list for orders
for (col in names(train)){
train_col<-as.data.frame(train[[col]],row.names=rownames(train)) # convert dataframe column to dataframe
colnames(train_col)<-c(col) # set column name to match
bc_K_v[[col]]<-f_ords(train_col,freq=365.25,freqs=c(7),ords=ords,bc=TRUE) # find best fourier coefficients
}
# vertical predictions & DEC
ords<-params<-expand.grid(seq(3)) # all combinations of fourier orders to try
dec_K_v <- sapply(names(train),function(x) NULL) # initialize empty list for orders
for (col in names(train)){
train_col<-as.data.frame(train[[col]],row.names=rownames(train)) # convert dataframe column to dataframe
colnames(train_col)<-c(col) # set column name to match
dec_K_v[[col]]<-f_ords(train_col,freq=365.25,freqs=c(7),ords=ords,dec=TRUE) # find best fourier coefficients
}
# vertical predictions & DEC & BC
ords<-params<-expand.grid(seq(3)) # all combinations of fourier orders to try
dec_bc_K_v <- sapply(names(train),function(x) NULL) # initialize empty list for orders
for (col in names(train)){
train_col<-as.data.frame(train[[col]],row.names=rownames(train)) # convert dataframe column to dataframe
colnames(train_col)<-c(col) # set column name to match
dec_bc_K_v[[col]]<-f_ords(train_col,freq=365.25,freqs=c(7),ords=ords,dec=TRUE,bc=TRUE) # find best fourier coefficients
}
K_v
names(train)
?values
sapply(K_v, function(x) {as.numeric(x[2])})
K_v
sapply(K_v, function(x) {as.numeric(x)})
length(c(3,3,3,3,3,3,3,3,1,2,1,2,3,3,3,3,3,3,3,3,2,2,2,2,3,3,3,3,3,3,3,2,2,3,2,2,3,2,3,2,3,3,2,2,3,3,3))
length(c(3,3,3,3,3,3,3,3,1,2,1,2,3,3,3,3,3,3,3,3,2,2,2,2,3,3,3,3,3,3,3,3,2,2,3,2,2,3,2,3,2,3,3,2,2,3,3,3))
K<-list(3,3,3,3,3,3,3,3,1,2,1,2,3,3,3,3,3,3,3,3,2,2,2,2,3,3,3,3,3,3,3,3,2,2,3,2,2,3,2,3,2,3,3,2,2,3,3,3)
names(K)
names(K)<-names(train)
K
sapply(K, function(x) {as.numeric(x)})
sapply(K_v, function(x) {as.numeric(x)})
sapply(bc_K_v, function(x) {as.numeric(x)})
list(3,3,3,3,3,3,3,31,2,2,2,1,3,3,3,3,3,3,3,3,2,2,2,3,3,2,2,2,3,2,3,2,2,2,2,2,3,2,3,2,3,3,2,1,2,3,3)
K
setdiff(K,K_v)
setdiff(K,bc_K_v)
setdiff(c(K),c(bc_K_v))
params<-data.frame(row.names=c('np','bc,','dec,','dec,bc,'),'bc'=c(FALSE,TRUE,FALSE,TRUE),'dec'=c(FALSE,FALSE,TRUE,TRUE),'K_v'=c(K_v,bc_K_v,dec_K_v,dec_bc_K_v))
params
name='dec,bc,'
bc=params[name,]$bc
dec=params[name,]$dec
params[name,]$K_v
K<-list('K_v'=K_v,'bc_K_v'=bc_K_v,'dec_K_v'=dec_K_v,'dec_bc_K_v'=dec_bc_K_v)
K
K$K_v
K<-list('np,'=K_v,'bc,'=bc_K_v,'dec,'=dec_K_v,'dec,bc,'=dec_bc_K_v)
K$bc,
K$'bc,'
data_dir<-'C:/Users/SABA/Google Drive/mtsg/data/nocb/arima/data/' # directory containing data
train<-load(paste(data_dir,'train_full.csv', sep='')) # load train set
f_ords<-function(train,freq=48,freqs,ords,dec=FALSE,bc=FALSE){
train<-c(t(train)) # flatten train set
aicc_best<-Inf # best aicc statistic
param_best<-NULL # best parameters
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
for (i in 1:nrow(ords)){ # for each combination of orders
ord<-unlist(ords[i,]) # combination of orders
xreg_train<-fourier(msts(train,seasonal.periods=freqs),K=ord) # fourier terms for particular multi-seasonal time series
if (dec) # if decompose first
{
fit=stlm(ts(train,frequency = freq),method='arima',xreg=xreg_train,s.window='periodic',robust=TRUE,trace=TRUE,lambda = bc_lambda)$model  # find best arima model after decomposition
}
else{ # dont decompose
fit=auto.arima(ts(train,frequency = freq),xreg=xreg_train,seasonal=FALSE,trace=TRUE,lambda = bc_lambda) # find best arima model
}
if (fit$aicc<aicc_best){ # if there is an improvement in aicc statistic
ord_best<-ord # save these orders
aicc_best<-fit$aicc # save new best aicc value
}
}
return(ord_best)
}
arima<-function(train,test,hor=1,batch=7,freq=48,freqs=NULL,ord=NULL,wxregs_train=NULL,wxregs_test=NULL,bc=FALSE,dec=FALSE){
test_pred<-data.frame(matrix(data=NA,nrow=nrow(test),ncol=ncol(test),dimnames=list(rownames(test),colnames(test))),check.names = FALSE) # initialize matrix for predictions
train<-c(t(train)) # flatten train set
test<-c(t(test)) # flatten test set
if (is.null(ord)){ # not considering multiple seasonalities
fxregs_train<-NULL
fxregs_test<-NULL
}
else { # considering multiple seasonalities
fxregs_train<-fourier(msts(train,seasonal.periods=freqs),K=ord)
fxregs_test<-fourier(msts(test,seasonal.periods=freqs),K=ord)
}
if (is.null(wxregs_train)|is.null(wxregs_test)) # not considering weather regressors
{
wxregs_train<-NULL
wxregs_test<-NULL
}
else{ # considering weather regressors
wxregs_train<-do.call(cbind,lapply(wxregs_train,function(x) c(t(x)))) # flatten and combine weather regressors for train set
wxregs_test<-do.call(cbind,lapply(wxregs_test,function(x) c(t(x)))) # flatten and combine weather regressors for test set
}
xregs_train<-cbind(fxregs_train,wxregs_train) # combine fourier & weather into one matrix for train set
xregs_test<-cbind(fxregs_test,wxregs_test) # combine fourier & weather into one matrix for test set
xregs=NULL # default covariates
xregs_pred=NULL # default covariates for predictions
for (i in seq(0,length(test)-hor,hor)){ # for each window of observations in test set
train_ts<-ts(c(train,test[seq_len(i)]),frequency=freq) # add new observations from test set to the current train set
if (!is.null(xregs_train)&!is.null(xregs_test)){ # if considering external regressors
xregs<-rbind(xregs_train,xregs_test[seq_len(i),]) # add covariates corresponding to new observations
xregs_pred<-matrix(xregs_test[i+seq_len(hor),],ncol=ncol(xregs_test)) # add covariates for predictions
}
if (i%%(batch*hor)==0){ # if its time to retrain
model<-NULL
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
if (dec){ # if decomposition is to be applied
model<-stlm(train_ts,method='arima',xreg=xregs,s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE,trace=TRUE) # find best model on the current train set
}
else { # no decomposition
model<-auto.arima(train_ts,xreg=xregs,lambda=bc_lambda,biasadj = FALSE,trace = TRUE) # find best model on the current train set
}
cat(i%/%(batch*hor),'\n') # print number of retrainings and the type of model
}
else{ # it is not the time to retrain
if (dec){
model<-stlm(train_ts,model=model$model,modelfunction=function(x, ...) {Arima(x, xreg=xregs, ...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE) # do not train, use current model with new observations
}
else
{
model<-Arima(train_ts,model=model,xreg=xregs,lambda=bc_lambda,biasadj=FALSE) # do not train, use current model with new observations
}
}
test_pred[(i%/%hor)+1,]<-forecast(model,h=hor,xreg=xregs_pred,lambda=bc_lambda,biasadj=FALSE)$mean # predict new values
}
return(test_pred)
}
arima_h<-function(train,test,batch=7,freq=48,freqs=NULL,ord=NULL,wxregs_train=NULL,wxregs_test=NULL,bc=FALSE,dec=FALSE){
return(arima(train,test,hor=48,batch=batch,freq=freq,freqs=freqs,ord=ord,wxregs_train=wxregs_train,wxregs_test=wxregs_test,bc = bc,dec = dec))
}
arima_v<-function(train,test,batch=7,freq=7,ord=NULL,freqs=NULL,wxregs_train=NULL,wxregs_test=NULL,bc=FALSE,dec=FALSE){
test_pred<-data.frame(matrix(data=NA,nrow=nrow(test),ncol=ncol(test),dimnames=list(rownames(test),colnames(test))),check.names = FALSE) # initialize dataframe for predictions
for (col in names(train)){
train_col<-as.data.frame(train[[col]],row.names=rownames(train)) # convert dataframe column to dataframe
test_col<-as.data.frame(test[[col]],row.names=rownames(test)) # convert dataframe column to dataframe
colnames(train_col)<-c(col) # set column name to match
colnames(test_col)<-c(col) # set column name to match
ord_col= if (!is.null(ord)) ord[[col]] else ord
if (is.null(wxregs_train)|is.null(wxregs_test)) # no weather regressors
{
wxregs_train_col<-NULL
wxregs_test_col<-NULL
}
else # consider weather regressors
{
wxregs_train_col<-lapply(wxregs_train,function(x) as.data.frame(`[[`(x, col))) # extract a particular column from each member of list of covariates
wxregs_test_col<-lapply(wxregs_test,function(x) as.data.frame(`[[`(x, col))) # extract a particular column from each member of list of covariates
}
test_pred[[col]]<-arima(train_col,test_col,hor=1,batch=batch,freq=freq,freqs=freqs,ord=ord_col,wxregs_train=wxregs_train_col,wxregs_test=wxregs_test_col)[[col]] # predictions
}
return(test_pred)
}
# ESTIMATE FOURIER ORDERS
data_dir<-'C:/Users/SABA/Google Drive/mtsg/data/nocb/arima/data/' # directory containing data
train<-load(paste(data_dir,'train_full.csv', sep='')) # load train set
ords=params<-expand.grid(seq(from=5,to=20,by=5),seq(from=10,to=50,by=10)) # all combinations of fourier orders to try
ord_h<-f_ords(train,freq=365.25*48,freqs=c(48,7*48),ords=ords) # find best fourier coefficients
train<-load(paste(data_dir,'train.csv', sep='')) # load train set
ords=params<-expand.grid(c(5,10,15,20),c(10,25,50)) # all combinations of fourier orders to try
ord_h<-f_ords(train,freq=365.25*48,freqs=c(48,7*48),ords=ords) # find best fourier coefficients
?gc
gc()
if (NULL)
print('ok')
?arima
?Arima
library(forecast)
source('dataprep.R')
f_ords<-function(train,freq=48,freqs,ords,dec=FALSE,bc=FALSE){
train<-c(t(train)) # flatten train set
aicc_best<-Inf # best aicc statistic
param_best<-NULL # best parameters
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
model<-NULL
for (i in 1:nrow(ords)){ # for each combination of orders
ord<-unlist(ords[i,]) # combination of orders
xregs_train<-fourier(msts(train,seasonal.periods=freqs),K=ord) # fourier terms for particular multi-seasonal time series
if (dec) # if decompose first
{
if (is.null(model)){
model<-stlm(ts(train,frequency = freq),method='arima',xreg=xregs_train,s.window='periodic',robust=TRUE,trace=TRUE,lambda = bc_lambda)$model  # find best arima model after decomposition
}
else{
model<-stlm(train_ts,model=model,modelfunction=function(x, ...) {Arima(x, xreg=xregs_train, ...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE,trace=TRUE) # do not train, use current model with new observations
}
}
else{ # dont decompose
if (is.null(model)){
model<-auto.arima(ts(train,frequency = freq),xreg=xregs_train,seasonal=FALSE,trace=TRUE,lambda = bc_lambda) # find best arima model
}
else{
model<-Arima(ts(train,frequency = freq),model=model,xreg=xregs_train,lambda=bc_lambda,biasadj=FALSE,trace=TRUE) # re-estimate the model
}
}
if (fit$aicc<aicc_best){ # if there is an improvement in aicc statistic
ord_best<-ord # save these orders
aicc_best<-fit$aicc # save new best aicc value
}
}
return(ord_best)
}
data_dir<-'C:/Users/SABA/Google Drive/mtsg/data/nocb/arima/data/' # directory containing data
train<-load(paste(data_dir,'train_full.csv', sep='')) # load train set
ords=params<-expand.grid(c(5,10,15,20),c(10,25,50)) # all combinations of fourier orders to try
ord_h<-f_ords(train,freq=365.25*48,freqs=c(48,7*48),ords=ords) # find best fourier coefficients
?auto.arima
?stlm
?Arima
f_ords<-function(train,freq=48,freqs,ords,ord=NULL,dec=FALSE,bc=FALSE){
train<-c(t(train)) # flatten train set
aicc_best<-Inf # best aicc statistic
param_best<-NULL # best parameters
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
for (i in 1:nrow(ords)){ # for each combination of orders
ord<-unlist(ords[i,]) # combination of orders
xregs_train<-fourier(msts(train,seasonal.periods=freqs),K=ord) # fourier terms for particular multi-seasonal time series
if (dec) # if decompose first
{
if (!is.null(model)){
model<-stlm(train_ts,model=model,modelfunction=function(x, ...) {Arima(x, xreg=xregs_train, ...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE,trace=TRUE)$model # do not train, use current model with new observations
}
else if (!is.null(ord)){
model<-stlm(train_ts,modelfunction=function(x, ...) {Arima(x, xreg=xregs_train, order=ord,...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE,trace=TRUE)$model # do not train, use current model with new observations
}
else{
model<-stlm(ts(train,frequency = freq),method='arima',xreg=xregs_train,s.window='periodic',robust=TRUE,trace=TRUE,lambda = bc_lambda)$model  # find best arima model after decomposition
}
}
else{ # dont decompose
if (!is.null(model)){
model<-Arima(ts(train,frequency = freq),model=model,xreg=xregs_train,lambda=bc_lambda,biasadj=FALSE,trace=TRUE) # re-estimate the model
}
else if (!is.null(ord)){
model<-Arima(ts(train,frequency = freq),order=ord,xreg=xregs_train,lambda=bc_lambda,biasadj=FALSE,trace=TRUE) # re-estimate the model
}
else{
model<-auto.arima(ts(train,frequency = freq),xreg=xregs_train,seasonal=FALSE,trace=TRUE,lambda = bc_lambda) # find best arima model
}
}
if (model$aicc<aicc_best){ # if there is an improvement in aicc statistic
ord_best<-ord # save these orders
aicc_best<-model$aicc # save new best aicc value
}
}
return(ord_best)
}
ords=params<-expand.grid(c(5,10,15,20),c(10,25,50)) # all combinations of fourier orders to try
data_dir<-'C:/Users/SABA/Google Drive/mtsg/data/nocb/arima/data/' # directory containing data
train<-load(paste(data_dir,'train_full.csv', sep='')) # load train set
ords=params<-expand.grid(c(5,10,15,20),c(10,25,50)) # all combinations of fourier orders to try
ord_h<-f_ords(train,freq=365.25*48,freqs=c(48,7*48),ords=ords,ord=c(0,1,5)) # find best fourier coefficients
f_ords<-function(train,freq=48,freqs,ords,ord=NULL,dec=FALSE,bc=FALSE){
train<-c(t(train)) # flatten train set
aicc_best<-Inf # best aicc statistic
param_best<-NULL # best parameters
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
model<-NULL
for (i in 1:nrow(ords)){ # for each combination of orders
ord<-unlist(ords[i,]) # combination of orders
xregs_train<-fourier(msts(train,seasonal.periods=freqs),K=ord) # fourier terms for particular multi-seasonal time series
if (dec) # if decompose first
{
if (!is.null(model)){
model<-stlm(train_ts,model=model,modelfunction=function(x, ...) {Arima(x, xreg=xregs_train, ...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE,trace=TRUE)$model # do not train, use current model with new observations
}
else if (!is.null(ord)){
model<-stlm(train_ts,modelfunction=function(x, ...) {Arima(x, xreg=xregs_train, order=ord,...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE,trace=TRUE)$model # do not train, use current model with new observations
}
else{
model<-stlm(ts(train,frequency = freq),method='arima',xreg=xregs_train,s.window='periodic',robust=TRUE,trace=TRUE,lambda = bc_lambda)$model  # find best arima model after decomposition
}
}
else{ # dont decompose
if (!is.null(model)){
model<-Arima(ts(train,frequency = freq),model=model,xreg=xregs_train,lambda=bc_lambda,biasadj=FALSE,trace=TRUE) # re-estimate the model
}
else if (!is.null(ord)){
model<-Arima(ts(train,frequency = freq),order=ord,xreg=xregs_train,lambda=bc_lambda,biasadj=FALSE,trace=TRUE) # re-estimate the model
}
else{
model<-auto.arima(ts(train,frequency = freq),xreg=xregs_train,seasonal=FALSE,trace=TRUE,lambda = bc_lambda) # find best arima model
}
}
if (model$aicc<aicc_best){ # if there is an improvement in aicc statistic
ord_best<-ord # save these orders
aicc_best<-model$aicc # save new best aicc value
}
}
return(ord_best)
}
ord_h<-f_ords(train,freq=365.25*48,freqs=c(48,7*48),ords=ords,ord=c(0,1,5)) # find best fourier coefficients
f_ords<-function(train,freq=48,freqs,ords,ord=NULL,dec=FALSE,bc=FALSE){
train<-c(t(train)) # flatten train set
aicc_best<-Inf # best aicc statistic
param_best<-NULL # best parameters
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
model<-NULL
for (i in 1:nrow(ords)){ # for each combination of orders
ord<-unlist(ords[i,]) # combination of orders
xregs_train<-fourier(msts(train,seasonal.periods=freqs),K=ord) # fourier terms for particular multi-seasonal time series
if (dec) # if decompose first
{
if (!is.null(model)){
model<-stlm(train_ts,model=model,modelfunction=function(x, ...) {Arima(x, xreg=xregs_train, ...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE)$model # do not train, use current model with new observations
}
else if (!is.null(ord)){
model<-stlm(train_ts,modelfunction=function(x, ...) {Arima(x, xreg=xregs_train, order=ord,...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE)$model # do not train, use current model with new observations
}
else{
model<-stlm(ts(train,frequency = freq),method='arima',xreg=xregs_train,s.window='periodic',robust=TRUE,trace=TRUE,lambda = bc_lambda)$model  # find best arima model after decomposition
}
}
else{ # dont decompose
if (!is.null(model)){
model<-Arima(ts(train,frequency = freq),model=model,xreg=xregs_train,lambda=bc_lambda,biasadj=FALSE) # re-estimate the model
}
else if (!is.null(ord)){
model<-Arima(ts(train,frequency = freq),order=ord,xreg=xregs_train,lambda=bc_lambda,biasadj=FALSE) # re-estimate the model
}
else{
model<-auto.arima(ts(train,frequency = freq),xreg=xregs_train,seasonal=FALSE,trace=TRUE,lambda = bc_lambda) # find best arima model
}
}
if (model$aicc<aicc_best){ # if there is an improvement in aicc statistic
ord_best<-ord # save these orders
aicc_best<-model$aicc # save new best aicc value
}
cat(ord,model$aicc,'\n')
}
return(ord_best)
}
ords=params<-expand.grid(c(5,10,15,20),c(10,25,50)) # all combinations of fourier orders to try
ord_h<-f_ords(train,freq=365.25*48,freqs=c(48,7*48),ords=ords,ord=c(0,1,5)) # find best fourier coefficients
f_ords<-function(train,freq=48,freqs,ords,ar_ord=NULL,dec=FALSE,bc=FALSE){
train<-c(t(train)) # flatten train set
aicc_best<-Inf # best aicc statistic
param_best<-NULL # best parameters
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
model<-NULL
for (i in 1:nrow(ords)){ # for each combination of orders
ord<-unlist(ords[i,]) # combination of orders
xregs_train<-fourier(msts(train,seasonal.periods=freqs),K=ord) # fourier terms for particular multi-seasonal time series
if (dec) # if decompose first
{
if (!is.null(model)){
model<-stlm(train_ts,model=model,modelfunction=function(x, ...) {Arima(x, xreg=xregs_train, ...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE)$model # do not train, use current model with new observations
}
else if (!is.null(ar_ord)){
model<-stlm(train_ts,modelfunction=function(x, ...) {Arima(x, xreg=xregs_train, order=ar_ord,...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE)$model # do not train, use current model with new observations
}
else{
model<-stlm(ts(train,frequency = freq),method='arima',xreg=xregs_train,s.window='periodic',robust=TRUE,trace=TRUE,lambda = bc_lambda)$model  # find best arima model after decomposition
}
}
else{ # dont decompose
if (!is.null(model)){
model<-Arima(ts(train,frequency = freq),model=model,xreg=xregs_train,lambda=bc_lambda,biasadj=FALSE) # re-estimate the model
}
else if (!is.null(ar_ord)){
model<-Arima(ts(train,frequency = freq),order=ar_ord,xreg=xregs_train,lambda=bc_lambda,biasadj=FALSE) # re-estimate the model
}
else{
model<-auto.arima(ts(train,frequency = freq),xreg=xregs_train,seasonal=FALSE,trace=TRUE,lambda = bc_lambda) # find best arima model
}
}
if (model$aicc<aicc_best){ # if there is an improvement in aicc statistic
ord_best<-ord # save these orders
aicc_best<-model$aicc # save new best aicc value
}
cat(ord,model$aicc,'\n')
}
return(ord_best)
}
ords=params<-expand.grid(c(5,10,15,20),c(10,25,50)) # all combinations of fourier orders to try
ord_h<-f_ords(train,freq=365.25*48,freqs=c(48,7*48),ords=ords,ar_ord=c(0,1,5)) # find best fourier coefficients
ord_h<-f_ords(train,freq=365.25*48,freqs=c(48,7*48),ords=ords,ar_ord=c(0,1,5)) # find best fourier coefficients
ncol(xreg)
ncol(model$xreg)
?arimaorder
f_ords<-function(train,freq=48,freqs,ords,ar_ord=NULL,dec=FALSE,bc=FALSE){
train<-c(t(train)) # flatten train set
aicc_best<-Inf # best aicc statistic
param_best<-NULL # best parameters
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
for (i in 1:nrow(ords)){ # for each combination of orders
ord<-unlist(ords[i,]) # combination of orders
xregs_train<-fourier(msts(train,seasonal.periods=freqs),K=ord) # fourier terms for particular multi-seasonal time series
if (dec) # if decompose first
{
if (!is.null(ar_ord)){
model<-stlm(train_ts,modelfunction=function(x, ...) {Arima(x, xreg=xregs_train, order=ar_ord,...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE)$model # do not train, use current model with new observations
}
else{
model<-stlm(ts(train,frequency = freq),method='arima',xreg=xregs_train,s.window='periodic',robust=TRUE,trace=TRUE,lambda = bc_lambda)$model  # find best arima model after decomposition
ar_ord<-arimaorder(model)
}
}
else{ # dont decompose
if (!is.null(ar_ord)){
model<-Arima(ts(train,frequency = freq),order=ar_ord,xreg=xregs_train,lambda=bc_lambda,biasadj=FALSE) # re-estimate the model
}
else{
model<-auto.arima(ts(train,frequency = freq),xreg=xregs_train,seasonal=FALSE,trace=TRUE,lambda = bc_lambda) # find best arima model
ar_ord<-arimaorder(model)
}
}
if (model$aicc<aicc_best){ # if there is an improvement in aicc statistic
ord_best<-ord # save these orders
aicc_best<-model$aicc # save new best aicc value
}
cat(ord,model$aicc,'\n')
}
return(ord_best)
}
f_ords<-function(train,freq=48,freqs,ords,ar_ord=NULL,dec=FALSE,bc=FALSE){
train<-c(t(train)) # flatten train set
aicc_best<-Inf # best aicc statistic
param_best<-NULL # best parameters
bc_lambda<-if (bc) BoxCox.lambda(train,method='guerrero') else NULL # estimate lambda for Box-Cox transformation
for (i in 1:nrow(ords)){ # for each combination of orders
ord<-unlist(ords[i,]) # combination of orders
xregs_train<-fourier(msts(train,seasonal.periods=freqs),K=ord) # fourier terms for particular multi-seasonal time series
if (dec) # if decompose first
{
if (!is.null(ar_ord)){
model<-stlm(train_ts,modelfunction=function(x, ...) {Arima(x, xreg=xregs_train, order=ar_ord,...)},s.window='periodic',robust=TRUE,lambda=bc_lambda,biasadj = FALSE)$model # do not train, use current model with new observations
}
else{
model<-stlm(ts(train,frequency = freq),method='arima',xreg=xregs_train,s.window='periodic',robust=TRUE,trace=TRUE,lambda = bc_lambda)$model  # find best arima model after decomposition
ar_ord<-arimaorder(model)
}
}
else{ # dont decompose
if (!is.null(ar_ord)){
model<-Arima(ts(train,frequency = freq),order=ar_ord,xreg=xregs_train,lambda=bc_lambda,biasadj=FALSE) # re-estimate the model
}
else{
model<-auto.arima(ts(train,frequency = freq),xreg=xregs_train,seasonal=FALSE,trace=TRUE,lambda = bc_lambda) # find best arima model
ar_ord<-arimaorder(model)
}
}
if (model$aicc<aicc_best){ # if there is an improvement in aicc statistic
ord_best<-ord # save these orders
aicc_best<-model$aicc # save new best aicc value
}
cat(ord,model$aicc,'\n')
}
return(ord_best)
}
train<-load(paste(data_dir,'train_full.csv', sep='')) # load train set
ords=params<-expand.grid(c(5,10,15,20),c(10,25,50)) # all combinations of fourier orders to try
ord_h<-f_ords(train,freq=365.25*48,freqs=c(48,7*48),ords=ords,ar_ord=c(0,1,5)) # find best fourier coefficients
